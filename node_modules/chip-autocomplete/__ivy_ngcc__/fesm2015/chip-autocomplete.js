import { Injectable, ɵɵdefineInjectable, EventEmitter, Component, ChangeDetectionStrategy, forwardRef, Input, Output, ViewChild, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormBuilder, ReactiveFormsModule } from '@angular/forms';
import { MatAutocomplete, MatAutocompleteModule } from '@angular/material/autocomplete';
import { Subject, timer } from 'rxjs';
import { debounce, distinctUntilChanged } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { MatChipsModule } from '@angular/material/chips';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatIconModule } from '@angular/material/icon';
import { MatSelectModule } from '@angular/material/select';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { MatCheckboxModule } from '@angular/material/checkbox';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/chip-autocomplete.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/forms';
import * as ɵngcc2 from '@angular/material/form-field';
import * as ɵngcc3 from '@angular/material/chips';
import * as ɵngcc4 from '@angular/common';
import * as ɵngcc5 from '@angular/material/autocomplete';
import * as ɵngcc6 from '@angular/material/icon';
import * as ɵngcc7 from '@angular/material/core';
import * as ɵngcc8 from '@angular/material/checkbox';

const _c0 = ["input"];
function ChipAutocompleteComponent_mat_chip_4_mat_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon", 12);
    ɵngcc0.ɵɵtext(1, "cancel");
    ɵngcc0.ɵɵelementEnd();
} }
function ChipAutocompleteComponent_mat_chip_4_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "mat-chip", 10);
    ɵngcc0.ɵɵlistener("removed", function ChipAutocompleteComponent_mat_chip_4_Template_mat_chip_removed_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const ctr_r6 = ctx.$implicit; const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.remove(ctr_r6); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵtemplate(2, ChipAutocompleteComponent_mat_chip_4_mat_icon_2_Template, 2, 0, "mat-icon", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctr_r6 = ctx.$implicit;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("removable", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.isOptionString ? ctr_r6 : ctr_r6[ctx_r1.displayWith], " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.removable);
} }
function ChipAutocompleteComponent_ng_container_9_mat_option_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-option", 14);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctr_r11 = ctx.$implicit;
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("value", ctr_r11)("disabled", ctx_r10.disabledSelected && ctx_r10.isSelected(ctr_r11));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r10.isOptionString ? ctr_r11 : ctr_r11[ctx_r10.displayWith], " ");
} }
function ChipAutocompleteComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ChipAutocompleteComponent_ng_container_9_mat_option_1_Template, 2, 3, "mat-option", 13);
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.clientSideFilter ? ctx_r4.filteredOptions : ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r4.filteredOptions$));
} }
function ChipAutocompleteComponent_ng_container_10_mat_option_1_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "mat-option", 16);
    ɵngcc0.ɵɵelementStart(1, "div", 17);
    ɵngcc0.ɵɵlistener("click", function ChipAutocompleteComponent_ng_container_10_mat_option_1_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r15); const ctr_r13 = ctx.$implicit; const ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.clickCheckboxWrap($event, ctr_r13); });
    ɵngcc0.ɵɵelementStart(2, "mat-checkbox", 18);
    ɵngcc0.ɵɵlistener("change", function ChipAutocompleteComponent_ng_container_10_mat_option_1_Template_mat_checkbox_change_2_listener() { ɵngcc0.ɵɵrestoreView(_r15); const ctr_r13 = ctx.$implicit; const ctx_r16 = ɵngcc0.ɵɵnextContext(2); return ctx_r16.toggleSelection(ctr_r13); })("click", function ChipAutocompleteComponent_ng_container_10_mat_option_1_Template_mat_checkbox_click_2_listener($event) { return $event.stopPropagation(); });
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctr_r13 = ctx.$implicit;
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("value", ctr_r13);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("checked", ctx_r12.isSelected(ctr_r13))("disabled", !ctx_r12.isSelected(ctr_r13) && ctx_r12.control.value && ctx_r12.maxItems && ctx_r12.control.value.length >= ctx_r12.maxItems);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r12.isOptionString ? ctr_r13 : ctr_r13[ctx_r12.displayWith], " ");
} }
function ChipAutocompleteComponent_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, ChipAutocompleteComponent_ng_container_10_mat_option_1_Template, 4, 4, "mat-option", 15);
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r5.clientSideFilter ? ctx_r5.filteredOptions : ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r5.filteredOptions$));
} }
class ChipAutocompleteService {
    constructor() { }
}
ChipAutocompleteService.ɵfac = function ChipAutocompleteService_Factory(t) { return new (t || ChipAutocompleteService)(); };
ChipAutocompleteService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ChipAutocompleteService, factory: ChipAutocompleteService.ɵfac, providedIn: 'root' });
/** @nocollapse */
ChipAutocompleteService.ctorParameters = () => [];
/** @nocollapse */ ChipAutocompleteService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ChipAutocompleteService_Factory() { return new ChipAutocompleteService(); }, token: ChipAutocompleteService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChipAutocompleteService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/chip-autocomplete.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ChipAutocompleteComponent {
    /**
     * @param {?} fb
     */
    constructor(fb) {
        this.fb = fb;
        this.placeholder = 'Select';
        this.clientSideFilter = true;
        this.maxItems = null;
        this.removable = true;
        this.required = true;
        this.isOptionString = true;
        this.displayWith = 'value';
        this.itemId = 'key';
        this.disabledSelected = true;
        this.debounceTime = 500;
        this.isChipAddFromInput = false;
        this.isOptionCheckable = false;
        this.changeSearchkey = new EventEmitter();
        this.separatorKeysCodes = [13, 9];
        this.onTouch = (/**
         * @return {?}
         */
        () => { });
        this.onChange = (/**
         * @return {?}
         */
        () => { });
        this.disabled = false;
        this.debounceHelper = new Subject();
        this.isSelected = (/**
         * @param {?} option
         * @return {?}
         */
        (option) => {
            return this.control.value && this.control.value.some((/**
             * @param {?} ctr
             * @return {?}
             */
            ctr => this.isOptionString ? ctr === option : ctr[this.itemId] === option[this.itemId]));
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.changeInput('');
        this.form = this.fb.group({
            control: [''],
        });
        this.form.valueChanges.subscribe((/**
         * @param {?} form
         * @return {?}
         */
        form => {
            setTimeout((/**
             * @return {?}
             */
            () => this.onChange(form.control)), 0);
        }));
        this.debounceHelper.pipe(debounce((/**
         * @return {?}
         */
        () => timer(this.debounceTime))), distinctUntilChanged()).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => this.changeSearchkey.emit(res)));
        if (this.clientSideFilter) {
            if (this.options.some((/**
             * @param {?} option
             * @return {?}
             */
            option => typeof (option) === 'string'))) {
                this.isOptionString = true;
            }
            else {
                this.isOptionString = false;
            }
        }
    }
    /**
     * @return {?}
     */
    get control() {
        return this.form.get('control');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    add(event) {
        if (this.isChipAddFromInput && !this.matAutocomplete.showPanel) {
            /** @type {?} */
            const input = event.input;
            /** @type {?} */
            const value = event.value;
            if (this.isOptionString) {
                if ((value || '').trim()) {
                    this.control.setValue([...this.control.value || [], value.trim()]);
                }
            }
            else {
                /** @type {?} */
                const obj = {};
                obj[this.itemId] = value;
                obj[this.displayWith] = value;
                this.control.setValue([...this.control.value || [], obj]);
            }
            // Reset the input value
            if (input) {
                input.value = '';
            }
        }
    }
    /**
     * @param {?} chip
     * @return {?}
     */
    remove(chip) {
        /** @type {?} */
        const index = this.control.value.findIndex((/**
         * @param {?} ctr
         * @return {?}
         */
        (ctr) => this.isOptionString ? ctr === chip : ctr[this.itemId] === chip[this.itemId]));
        if (index >= 0) {
            this.changeInput();
            this.control.value.splice(index, 1);
            if (this.control.value.length === 0) {
                this.control.setValue(null);
            }
            else {
                this.control.updateValueAndValidity();
            }
            this.disabled = false;
        }
    }
    /**
     * @param {?=} key
     * @return {?}
     */
    changeInput(key = '') {
        this.clientSideFilter ? this.filteredOptions = this.filterOption(key) : this.debounceHelper.next(key);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    filterOption(key) {
        return (key === '') ? this.options : this.options.filter((/**
         * @param {?} f
         * @return {?}
         */
        f => this.isOptionString ? f.toLowerCase().includes(key.toLowerCase()) :
            (f[this.displayWith]).toLowerCase().includes(key.toLowerCase())));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onSelect(value) {
        this.control.setValue([...this.control.value || [], value]);
        this.afterSelect();
    }
    /**
     * @return {?}
     */
    afterSelect() {
        this.input.nativeElement.value = '';
        if (this.maxItems && this.control.value.length === this.maxItems) {
            this.disabled = true;
        }
        this.changeInput();
    }
    /**
     * @param {?} keyCode
     * @return {?}
     */
    chooseFirstOption(keyCode) {
        if (this.matAutocomplete.options.first && (!this.control.value || (this.control.value && !this.control.value.some((/**
         * @param {?} ctr
         * @return {?}
         */
        ctr => this.isOptionString ? ctr === this.matAutocomplete.options.first.value :
            ctr[this.itemId] === this.matAutocomplete.options.first.value[this.itemId]))))) {
            if (keyCode === 'enter') {
                this.matAutocomplete.options.first.select();
            }
            else if (keyCode === 'tab') {
                this.control.setValue([...this.control.value || [], this.matAutocomplete.options.first.value]);
                this.afterSelect();
            }
        }
    }
    /**
     * @param {?} $event
     * @param {?} option
     * @return {?}
     */
    clickCheckboxWrap($event, option) {
        $event.stopPropagation();
        this.toggleSelection(option);
    }
    /**
     * @param {?} option
     * @return {?}
     */
    toggleSelection(option) {
        if (this.isSelected(option)) {
            this.remove(option);
        }
        else {
            if (!this.control.value || !this.maxItems || this.control.value.length < this.maxItems) {
                this.onSelect(option);
            }
        }
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.input.nativeElement.value = '';
        this.changeInput();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouch = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    writeValue(val) {
        this.control.setValue(val);
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
ChipAutocompleteComponent.ɵfac = function ChipAutocompleteComponent_Factory(t) { return new (t || ChipAutocompleteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FormBuilder)); };
ChipAutocompleteComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ChipAutocompleteComponent, selectors: [["chip-autocomplete"]], viewQuery: function ChipAutocompleteComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵstaticViewQuery(MatAutocomplete, true);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.matAutocomplete = _t.first);
    } }, inputs: { placeholder: "placeholder", clientSideFilter: "clientSideFilter", maxItems: "maxItems", removable: "removable", required: "required", isOptionString: "isOptionString", displayWith: "displayWith", itemId: "itemId", disabledSelected: "disabledSelected", debounceTime: "debounceTime", isChipAddFromInput: "isChipAddFromInput", isOptionCheckable: "isOptionCheckable", options: "options", filteredOptions$: "filteredOptions$" }, outputs: { changeSearchkey: "changeSearchkey" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(( /**
                 * @return {?}
                 */() => ChipAutocompleteComponent)),
                multi: true
            }
        ])], decls: 11, vars: 10, consts: [[1, "form", 3, "formGroup"], [1, "form-element"], ["formControlName", "control", 3, "required"], ["chipList", ""], [3, "removable", "removed", 4, "ngFor", "ngForOf"], ["matInput", "", 3, "placeholder", "matChipInputFor", "matAutocomplete", "disabled", "matChipInputSeparatorKeyCodes", "input", "matChipInputTokenEnd", "keyup.enter", "keyup.tab", "blur", "focus"], ["input", ""], [3, "optionSelected"], ["ref", "matAutocomplete"], [4, "ngIf"], [3, "removable", "removed"], ["matChipRemove", "", 4, "ngIf"], ["matChipRemove", ""], [3, "value", "disabled", 4, "ngFor", "ngForOf"], [3, "value", "disabled"], ["class", "option-checkbox-wrap", 3, "value", 4, "ngFor", "ngForOf"], [1, "option-checkbox-wrap", 3, "value"], [3, "click"], [3, "checked", "disabled", "change", "click"]], template: function ChipAutocompleteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "form", 0);
        ɵngcc0.ɵɵelementStart(1, "mat-form-field", 1);
        ɵngcc0.ɵɵelementStart(2, "mat-chip-list", 2, 3);
        ɵngcc0.ɵɵtemplate(4, ChipAutocompleteComponent_mat_chip_4_Template, 3, 3, "mat-chip", 4);
        ɵngcc0.ɵɵelementStart(5, "input", 5, 6);
        ɵngcc0.ɵɵlistener("input", function ChipAutocompleteComponent_Template_input_input_5_listener($event) { return ctx.changeInput($event.target.value); })("matChipInputTokenEnd", function ChipAutocompleteComponent_Template_input_matChipInputTokenEnd_5_listener($event) { return ctx.add($event); })("keyup.enter", function ChipAutocompleteComponent_Template_input_keyup_enter_5_listener() { return ctx.chooseFirstOption("enter"); })("keyup.tab", function ChipAutocompleteComponent_Template_input_keyup_tab_5_listener() { return ctx.chooseFirstOption("tab"); })("blur", function ChipAutocompleteComponent_Template_input_blur_5_listener() { return ctx.onBlur(); })("focus", function ChipAutocompleteComponent_Template_input_focus_5_listener() { return ctx.changeInput(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "mat-autocomplete", 7, 8);
        ɵngcc0.ɵɵlistener("optionSelected", function ChipAutocompleteComponent_Template_mat_autocomplete_optionSelected_7_listener($event) { return ctx.onSelect($event.option.value); });
        ɵngcc0.ɵɵtemplate(9, ChipAutocompleteComponent_ng_container_9_Template, 3, 3, "ng-container", 9);
        ɵngcc0.ɵɵtemplate(10, ChipAutocompleteComponent_ng_container_10_Template, 3, 3, "ng-container", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(3);
        const _r3 = ɵngcc0.ɵɵreference(8);
        ɵngcc0.ɵɵproperty("formGroup", ctx.form);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("required", ctx.required);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.control.value);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("placeholder", ctx.placeholder)("matChipInputFor", _r0)("matAutocomplete", _r3)("disabled", ctx.disabled)("matChipInputSeparatorKeyCodes", ctx.separatorKeysCodes);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isOptionCheckable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isOptionCheckable);
    } }, directives: [ɵngcc1.ɵangular_packages_forms_forms_y, ɵngcc1.NgControlStatusGroup, ɵngcc1.FormGroupDirective, ɵngcc2.MatFormField, ɵngcc3.MatChipList, ɵngcc1.NgControlStatus, ɵngcc1.FormControlName, ɵngcc1.RequiredValidator, ɵngcc4.NgForOf, ɵngcc3.MatChipInput, ɵngcc5.MatAutocompleteTrigger, ɵngcc5.MatAutocomplete, ɵngcc4.NgIf, ɵngcc3.MatChip, ɵngcc6.MatIcon, ɵngcc3.MatChipRemove, ɵngcc7.MatOption, ɵngcc8.MatCheckbox], pipes: [ɵngcc4.AsyncPipe], styles: [".form[_ngcontent-%COMP%]{min-width:150px;max-width:500px;width:100%}.form-element[_ngcontent-%COMP%]{padding:5px 0 25px 40px;width:100%}.mat-option.option-checkbox-wrap[_ngcontent-%COMP%]{padding:0}.mat-option.option-checkbox-wrap[_ngcontent-%COMP%]   .mat-checkbox[_ngcontent-%COMP%]{padding:0 16px}.mat-option[_ngcontent-%COMP%]:first-child{background:rgba(0,0,0,.04)}"], changeDetection: 0 });
/** @nocollapse */
ChipAutocompleteComponent.ctorParameters = () => [
    { type: FormBuilder }
];
ChipAutocompleteComponent.propDecorators = {
    placeholder: [{ type: Input }],
    clientSideFilter: [{ type: Input }],
    options: [{ type: Input }],
    maxItems: [{ type: Input }],
    removable: [{ type: Input }],
    required: [{ type: Input }],
    isOptionString: [{ type: Input }],
    displayWith: [{ type: Input }],
    itemId: [{ type: Input }],
    disabledSelected: [{ type: Input }],
    filteredOptions$: [{ type: Input }],
    debounceTime: [{ type: Input }],
    isChipAddFromInput: [{ type: Input }],
    isOptionCheckable: [{ type: Input }],
    changeSearchkey: [{ type: Output }],
    input: [{ type: ViewChild, args: ['input', { static: false },] }],
    matAutocomplete: [{ type: ViewChild, args: [MatAutocomplete, { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChipAutocompleteComponent, [{
        type: Component,
        args: [{
                selector: 'chip-autocomplete',
                template: "<form [formGroup]=\"form\" class=\"form\">\n    <mat-form-field class=\"form-element\">\n        <mat-chip-list #chipList formControlName=\"control\" [required]=\"required\">\n            <mat-chip *ngFor=\"let ctr of control.value\" [removable]=\"true\" (removed)=\"remove(ctr)\">\n                {{ isOptionString ? ctr : ctr[displayWith] }}\n                <mat-icon matChipRemove *ngIf=\"removable\">cancel</mat-icon>\n            </mat-chip>\n            <input #input matInput [placeholder]=\"placeholder\" (input)=\"changeInput($event.target.value)\"\n                [matChipInputFor]=\"chipList\" [matAutocomplete]=\"ref\" (matChipInputTokenEnd)=\"add($event)\"\n                [disabled]=\"disabled\" (keyup.enter)=\"chooseFirstOption('enter')\" (keyup.tab)=\"chooseFirstOption('tab')\"\n                (blur)=\"onBlur()\" (focus)=\"changeInput()\" [matChipInputSeparatorKeyCodes]=\"separatorKeysCodes\">\n            <mat-autocomplete #ref=\"matAutocomplete\" (optionSelected)=\"onSelect($event.option.value)\">\n                <ng-container *ngIf=\"!isOptionCheckable\">\n                    <mat-option *ngFor=\"let ctr of (clientSideFilter? filteredOptions : (filteredOptions$ | async))\"\n                        [value]=\"ctr\" [disabled]=\"disabledSelected && isSelected(ctr)\">\n                        {{ isOptionString ? ctr : ctr[displayWith] }}\n                    </mat-option>\n                </ng-container>\n                <ng-container *ngIf=\"isOptionCheckable\">\n                    <mat-option class=\"option-checkbox-wrap\" *ngFor=\"let ctr of (clientSideFilter? filteredOptions : (filteredOptions$ | async))\"\n                        [value]=\"ctr\">\n                        <div (click)=\"clickCheckboxWrap($event, ctr)\">\n                            <mat-checkbox [checked]=\"isSelected(ctr)\"\n                                [disabled]=\"!isSelected(ctr) && control.value && maxItems && control.value.length >= maxItems\"\n                                (change)=\"toggleSelection(ctr)\" (click)=\"$event.stopPropagation()\">\n                                {{ isOptionString ? ctr : ctr[displayWith] }}\n                            </mat-checkbox>\n                        </div>\n                    </mat-option>\n                </ng-container>\n            </mat-autocomplete>\n        </mat-chip-list>\n    </mat-form-field>\n</form>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(( /**
                         * @return {?}
                         */() => ChipAutocompleteComponent)),
                        multi: true
                    }
                ],
                styles: [".form{min-width:150px;max-width:500px;width:100%}.form-element{padding:5px 0 25px 40px;width:100%}.mat-option.option-checkbox-wrap{padding:0}.mat-option.option-checkbox-wrap .mat-checkbox{padding:0 16px}.mat-option:first-child{background:rgba(0,0,0,.04)}"]
            }]
    }], function () { return [{ type: ɵngcc1.FormBuilder }]; }, { placeholder: [{
            type: Input
        }], clientSideFilter: [{
            type: Input
        }], maxItems: [{
            type: Input
        }], removable: [{
            type: Input
        }], required: [{
            type: Input
        }], isOptionString: [{
            type: Input
        }], displayWith: [{
            type: Input
        }], itemId: [{
            type: Input
        }], disabledSelected: [{
            type: Input
        }], debounceTime: [{
            type: Input
        }], isChipAddFromInput: [{
            type: Input
        }], isOptionCheckable: [{
            type: Input
        }], changeSearchkey: [{
            type: Output
        }], options: [{
            type: Input
        }], filteredOptions$: [{
            type: Input
        }], input: [{
            type: ViewChild,
            args: ['input', { static: false }]
        }], matAutocomplete: [{
            type: ViewChild,
            args: [MatAutocomplete, { static: true }]
        }] }); })();
if (false) {
    /** @type {?} */
    ChipAutocompleteComponent.prototype.placeholder;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.clientSideFilter;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.options;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.maxItems;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.removable;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.required;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.isOptionString;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.displayWith;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.itemId;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.disabledSelected;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.filteredOptions$;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.debounceTime;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.isChipAddFromInput;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.isOptionCheckable;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.changeSearchkey;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.input;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.matAutocomplete;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.separatorKeysCodes;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.onTouch;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.onChange;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.form;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.filteredOptions;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.disabled;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.debounceHelper;
    /** @type {?} */
    ChipAutocompleteComponent.prototype.isSelected;
    /**
     * @type {?}
     * @private
     */
    ChipAutocompleteComponent.prototype.fb;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/chip-autocomplete.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ChipAutocompleteModule {
}
ChipAutocompleteModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ChipAutocompleteModule });
ChipAutocompleteModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ChipAutocompleteModule_Factory(t) { return new (t || ChipAutocompleteModule)(); }, imports: [[
            CommonModule,
            BrowserAnimationsModule,
            MatAutocompleteModule,
            MatCheckboxModule,
            MatChipsModule,
            MatFormFieldModule,
            MatIconModule,
            MatSelectModule,
            ReactiveFormsModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChipAutocompleteModule, { declarations: function () { return [ChipAutocompleteComponent]; }, imports: function () { return [CommonModule,
        BrowserAnimationsModule,
        MatAutocompleteModule,
        MatCheckboxModule,
        MatChipsModule,
        MatFormFieldModule,
        MatIconModule,
        MatSelectModule,
        ReactiveFormsModule]; }, exports: function () { return [ChipAutocompleteComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChipAutocompleteModule, [{
        type: NgModule,
        args: [{
                declarations: [ChipAutocompleteComponent],
                imports: [
                    CommonModule,
                    BrowserAnimationsModule,
                    MatAutocompleteModule,
                    MatCheckboxModule,
                    MatChipsModule,
                    MatFormFieldModule,
                    MatIconModule,
                    MatSelectModule,
                    ReactiveFormsModule
                ],
                exports: [ChipAutocompleteComponent]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: chip-autocomplete.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ChipAutocompleteComponent, ChipAutocompleteModule, ChipAutocompleteService };

//# sourceMappingURL=chip-autocomplete.js.map
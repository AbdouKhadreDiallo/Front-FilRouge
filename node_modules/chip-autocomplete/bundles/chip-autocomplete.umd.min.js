!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@angular/core"),require("@angular/forms"),require("@angular/material/autocomplete"),require("rxjs"),require("rxjs/operators"),require("@angular/common"),require("@angular/material/chips"),require("@angular/material/form-field"),require("@angular/material/icon"),require("@angular/material/select"),require("@angular/platform-browser/animations"),require("@angular/material/checkbox")):"function"==typeof define&&define.amd?define("chip-autocomplete",["exports","@angular/core","@angular/forms","@angular/material/autocomplete","rxjs","rxjs/operators","@angular/common","@angular/material/chips","@angular/material/form-field","@angular/material/icon","@angular/material/select","@angular/platform-browser/animations","@angular/material/checkbox"],e):e((t=t||self)["chip-autocomplete"]={},t.ng.core,t.ng.forms,t.ng.material.autocomplete,t.rxjs,t.rxjs.operators,t.ng.common,t.ng.material.chips,t.ng.material["form-field"],t.ng.material.icon,t.ng.material.select,t.ng.platformBrowser.animations,t.ng.material.checkbox)}(this,(function(t,e,o,i,n,r,a,l,c,s,p,u,h){"use strict";
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */function m(t,e){var o="function"==typeof Symbol&&t[Symbol.iterator];if(!o)return t;var i,n,r=o.call(t),a=[];try{for(;(void 0===e||e-- >0)&&!(i=r.next()).done;)a.push(i.value)}catch(t){n={error:t}}finally{try{i&&!i.done&&(o=r.return)&&o.call(r)}finally{if(n)throw n.error}}return a}function d(){for(var t=[],e=0;e<arguments.length;e++)t=t.concat(m(arguments[e]));return t}var f=function(){function t(){}return t.decorators=[{type:e.Injectable,args:[{providedIn:"root"}]}],t.ctorParameters=function(){return[]},t.ngInjectableDef=e.ɵɵdefineInjectable({factory:function(){return new t},token:t,providedIn:"root"}),t}(),g=function(){function t(t){var o=this;this.fb=t,this.placeholder="Select",this.clientSideFilter=!0,this.maxItems=null,this.removable=!0,this.required=!0,this.isOptionString=!0,this.displayWith="value",this.itemId="key",this.disabledSelected=!0,this.debounceTime=500,this.isChipAddFromInput=!1,this.isOptionCheckable=!1,this.changeSearchkey=new e.EventEmitter,this.separatorKeysCodes=[13,9],this.onTouch=function(){},this.onChange=function(){},this.disabled=!1,this.debounceHelper=new n.Subject,this.isSelected=function(t){return o.control.value&&o.control.value.some((function(e){return o.isOptionString?e===t:e[o.itemId]===t[o.itemId]}))}}return t.prototype.ngOnInit=function(){var t=this;this.changeInput(""),this.form=this.fb.group({control:[""]}),this.form.valueChanges.subscribe((function(e){setTimeout((function(){return t.onChange(e.control)}),0)})),this.debounceHelper.pipe(r.debounce((function(){return n.timer(t.debounceTime)})),r.distinctUntilChanged()).subscribe((function(e){return t.changeSearchkey.emit(e)})),this.clientSideFilter&&(this.options.some((function(t){return"string"==typeof t}))?this.isOptionString=!0:this.isOptionString=!1)},Object.defineProperty(t.prototype,"control",{get:function(){return this.form.get("control")},enumerable:!0,configurable:!0}),t.prototype.add=function(t){if(this.isChipAddFromInput&&!this.matAutocomplete.showPanel){var e=t.input,o=t.value;if(this.isOptionString)(o||"").trim()&&this.control.setValue(d(this.control.value||[],[o.trim()]));else{var i={};i[this.itemId]=o,i[this.displayWith]=o,this.control.setValue(d(this.control.value||[],[i]))}e&&(e.value="")}},t.prototype.remove=function(t){var e=this,o=this.control.value.findIndex((function(o){return e.isOptionString?o===t:o[e.itemId]===t[e.itemId]}));o>=0&&(this.changeInput(),this.control.value.splice(o,1),0===this.control.value.length?this.control.setValue(null):this.control.updateValueAndValidity(),this.disabled=!1)},t.prototype.changeInput=function(t){void 0===t&&(t=""),this.clientSideFilter?this.filteredOptions=this.filterOption(t):this.debounceHelper.next(t)},t.prototype.filterOption=function(t){var e=this;return""===t?this.options:this.options.filter((function(o){return e.isOptionString?o.toLowerCase().includes(t.toLowerCase()):o[e.displayWith].toLowerCase().includes(t.toLowerCase())}))},t.prototype.onSelect=function(t){this.control.setValue(d(this.control.value||[],[t])),this.afterSelect()},t.prototype.afterSelect=function(){this.input.nativeElement.value="",this.maxItems&&this.control.value.length===this.maxItems&&(this.disabled=!0),this.changeInput()},t.prototype.chooseFirstOption=function(t){var e=this;this.matAutocomplete.options.first&&(!this.control.value||this.control.value&&!this.control.value.some((function(t){return e.isOptionString?t===e.matAutocomplete.options.first.value:t[e.itemId]===e.matAutocomplete.options.first.value[e.itemId]})))&&("enter"===t?this.matAutocomplete.options.first.select():"tab"===t&&(this.control.setValue(d(this.control.value||[],[this.matAutocomplete.options.first.value])),this.afterSelect()))},t.prototype.clickCheckboxWrap=function(t,e){t.stopPropagation(),this.toggleSelection(e)},t.prototype.toggleSelection=function(t){this.isSelected(t)?this.remove(t):(!this.control.value||!this.maxItems||this.control.value.length<this.maxItems)&&this.onSelect(t)},t.prototype.onBlur=function(){this.input.nativeElement.value="",this.changeInput()},t.prototype.registerOnTouched=function(t){this.onTouch=t},t.prototype.registerOnChange=function(t){this.onChange=t},t.prototype.writeValue=function(t){this.control.setValue(t)},t.prototype.setDisabledState=function(t){this.disabled=t},t.decorators=[{type:e.Component,args:[{selector:"chip-autocomplete",template:'<form [formGroup]="form" class="form">\n    <mat-form-field class="form-element">\n        <mat-chip-list #chipList formControlName="control" [required]="required">\n            <mat-chip *ngFor="let ctr of control.value" [removable]="true" (removed)="remove(ctr)">\n                {{ isOptionString ? ctr : ctr[displayWith] }}\n                <mat-icon matChipRemove *ngIf="removable">cancel</mat-icon>\n            </mat-chip>\n            <input #input matInput [placeholder]="placeholder" (input)="changeInput($event.target.value)"\n                [matChipInputFor]="chipList" [matAutocomplete]="ref" (matChipInputTokenEnd)="add($event)"\n                [disabled]="disabled" (keyup.enter)="chooseFirstOption(\'enter\')" (keyup.tab)="chooseFirstOption(\'tab\')"\n                (blur)="onBlur()" (focus)="changeInput()" [matChipInputSeparatorKeyCodes]="separatorKeysCodes">\n            <mat-autocomplete #ref="matAutocomplete" (optionSelected)="onSelect($event.option.value)">\n                <ng-container *ngIf="!isOptionCheckable">\n                    <mat-option *ngFor="let ctr of (clientSideFilter? filteredOptions : (filteredOptions$ | async))"\n                        [value]="ctr" [disabled]="disabledSelected && isSelected(ctr)">\n                        {{ isOptionString ? ctr : ctr[displayWith] }}\n                    </mat-option>\n                </ng-container>\n                <ng-container *ngIf="isOptionCheckable">\n                    <mat-option class="option-checkbox-wrap" *ngFor="let ctr of (clientSideFilter? filteredOptions : (filteredOptions$ | async))"\n                        [value]="ctr">\n                        <div (click)="clickCheckboxWrap($event, ctr)">\n                            <mat-checkbox [checked]="isSelected(ctr)"\n                                [disabled]="!isSelected(ctr) && control.value && maxItems && control.value.length >= maxItems"\n                                (change)="toggleSelection(ctr)" (click)="$event.stopPropagation()">\n                                {{ isOptionString ? ctr : ctr[displayWith] }}\n                            </mat-checkbox>\n                        </div>\n                    </mat-option>\n                </ng-container>\n            </mat-autocomplete>\n        </mat-chip-list>\n    </mat-form-field>\n</form>',changeDetection:e.ChangeDetectionStrategy.OnPush,providers:[{provide:o.NG_VALUE_ACCESSOR,useExisting:e.forwardRef((function(){return t})),multi:!0}],styles:[".form{min-width:150px;max-width:500px;width:100%}.form-element{padding:5px 0 25px 40px;width:100%}.mat-option.option-checkbox-wrap{padding:0}.mat-option.option-checkbox-wrap .mat-checkbox{padding:0 16px}.mat-option:first-child{background:rgba(0,0,0,.04)}"]}]}],t.ctorParameters=function(){return[{type:o.FormBuilder}]},t.propDecorators={placeholder:[{type:e.Input}],clientSideFilter:[{type:e.Input}],options:[{type:e.Input}],maxItems:[{type:e.Input}],removable:[{type:e.Input}],required:[{type:e.Input}],isOptionString:[{type:e.Input}],displayWith:[{type:e.Input}],itemId:[{type:e.Input}],disabledSelected:[{type:e.Input}],filteredOptions$:[{type:e.Input}],debounceTime:[{type:e.Input}],isChipAddFromInput:[{type:e.Input}],isOptionCheckable:[{type:e.Input}],changeSearchkey:[{type:e.Output}],input:[{type:e.ViewChild,args:["input",{static:!1}]}],matAutocomplete:[{type:e.ViewChild,args:[i.MatAutocomplete,{static:!0}]}]},t}();var v=function(){function t(){}return t.decorators=[{type:e.NgModule,args:[{declarations:[g],imports:[a.CommonModule,u.BrowserAnimationsModule,i.MatAutocompleteModule,h.MatCheckboxModule,l.MatChipsModule,c.MatFormFieldModule,s.MatIconModule,p.MatSelectModule,o.ReactiveFormsModule],exports:[g]}]}],t}();t.ChipAutocompleteComponent=g,t.ChipAutocompleteModule=v,t.ChipAutocompleteService=f,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=chip-autocomplete.umd.min.js.map